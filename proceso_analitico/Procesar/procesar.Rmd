---
title: 'Procesamiento: Conjunto de datos de Cyclistic'
author: 
  - "Alfredo Aburto Alcudia"
  - "https://github.com/alabacw74/analisis-datos-bicicletas-compartidas"
date: "`r Sys.Date()`"
output:
   html_document:
    toc: true # Mostrar tabla de contenido en documento R markdown
    toc_depth: 5 # Niveles de la tabla de contenidoo
    toc_float: true # Mostrar la tabla de contenido en todo el documento
    collapsed: true # Si solo queremos que muestre el nivel principal
    smooth_scroll: true # Reflejar nuestra ubicación en barra de contenido
    theme: journal # Estilo del documento
    highlight: kate # Estilo del codigo
    df_print: paged # Estilo para mostrar los datos
    code_folding: show # Mostrar o no el código del documento
---

<div style="text-align: justify;">

## Objetivo 

En esta fase del analísis realizaremos las operaciones necesarias para obtener
los siguientes resultados:

1. Datos organizados
2. Datos limpios y filtrados
3. Una documentación detallada de cada operación

## Introducción

Como se menciono en la fase de `Prepararación` nuestro conjunto de datos incluye
la información sobre los viajes historicos en formato .zip, siendo en total
trece ficheros. Los conjuntos de datos superan el **millón de registros** es 
por eso que definir una herramienta adecuada para procesar los datos y 
posteriormente poder analizarlos de manera eficiente y profesional es de vital
importancia. Por lo anterior, en este documento incluimos la definición de la
herramienta a utilizar y la documentación de la limpieza de los datos para 
poder tener un flujo de trabajo adecuado y poder avanzar en el proceso de
analisís de los datos sin contratiempos.

## Importación de los datos

```{r carga_paquetes}
# Instala dplyr

# install.packages("tydyverse")

# Carga del paquete
library(tidyverse)
```

### Automatización de lectura de los archivos

La forma en la que se ha realizado la adquisición de los datos nos llevo a tener
archivos aislados con nombres diferentes, para poder realizar la lectura de los
archivos .csv extraidos y unirlos en un data frame creamos el siguiente script
que automatiza dicha tarea. El siguiente bloque de código se encarga de 
automatizar la lectura de archivos CSV correspondientes a datos de viajes 
en bicicleta durante los años 2020 y 2021. A continuación, se proporciona 
una documentación detallada del funcionamiento de este script:

#### Paso 1: Incialización de la lista
1. En este paso, se crea una lista llamada `lista_dataframes` que se utilizará 
para almacenar cada data frame importado.
   
```{r}
lista_dataframes <- list()
```

#### Paso 2: Estructura de Ciclos For

```{r}
# Iteramos sobre valores de la variable j (20 y 21) para los años 2020 y 2021
for (j in 20:21) {
  # Ajustamos la variable i según la estructura de los nombres de los archivos
  if (j == 20) {
    for (i in 4:12) {
      # Generamos el nombre de la variable y del archivo a leer
      nombre_variable <- paste("periodo_2020", sprintf("%02d", i), sep="")
      archivo_csv <- paste("~/Desktop/Analisis_de_datos/Cyclistic_Datasets/",
                           paste("20", j, sprintf("%02d", i), 
                                 "-divvy-tripdata.csv", sep=""),
                           sep="")
      
      # Leemos el archivo CSV y asignamos el resultado a la lista de data frames
      assign(nombre_variable, read_csv(archivo_csv))
      lista_dataframes[[nombre_variable]] <- get(nombre_variable)
    }
  } else {
    for (i in 1:4) {
      # Generamos el nombre de la variable y del archivo a leer
      nombre_variable <- paste("periodo_", paste("20", j, sprintf("%02d", i),
                                                 sep=""), sep="")
      archivo_csv <- paste("~/Desktop/Analisis_de_datos/Cyclistic_Datasets/",
                           paste("20", j, sprintf("%02d", i), 
                                 "-divvy-tripdata.csv", sep=""),
                           sep="")
      
      # Leemos el archivo CSV y asignamos el resultado a la lista de data frames
      assign(nombre_variable, read_csv(archivo_csv))
      lista_dataframes[[nombre_variable]] <- get(nombre_variable)
    }
  }
}

```

Este bloque de código realiza la lectura de archivos CSV de manera dinámica, 
adaptándose a la estructura de nombres de archivos para los años 2020 y 2021. 
Cada conjunto de datos leído se almacena en la lista lista_dataframes, 
facilitando su manipulación posterior. La estructura de ciclos y la generación 
dinámica de nombres garantizan la automatización del proceso de lectura y 
carga de datos.

## Limpieza de los datos

### Verificar tipos de datos

En esta sección del análisis, se busca verificar que todos los data frames 
tengan las mismas columnas con el mismo tipo de dato. Esto es esencial antes de
combinar los data frames en uno solo.

#### Paso 1: Creación de la Lista de Tipos de Datos

Para cada periodo de tiempo (ya sea del año 2020 o 2021), se crea una entrada 
en la lista `tipos_de_datos`. Se utiliza un bucle anidado para iterar sobre 
los periodos y las fechas, obteniendo así los tipos de datos de cada columna 
de cada data frame.

```{r}
tipos_de_datos <- list()

for (j in 20:21) {
  if (j == 20) {
    for (i in 4:12) {
      nombre_variable <- paste("periodo_2020", sprintf("%02d", i), sep="")
      tipos_de_datos[[nombre_variable]] <- sapply(get(nombre_variable), class)
    }
  } else {
    for (i in 1:4) {
      nombre_variable <- paste("periodo_", paste("20", j, sprintf("%02d", i), 
                                                 sep=""), sep="")
      tipos_de_datos[[nombre_variable]] <- sapply(get(nombre_variable), class)
    }
  }
}
```

#### Paso 2: Comparación de Tipos de datos

Luego de obtener los tipos de datos de cada columna de cada data frame, se 
realiza una comparación para verificar si todas las columnas tienen el mismo 
tipo de dato en todos los data frames.

```{r}
comparacion_tipos <- all(sapply(tipos_de_datos[-1],
                                function(x) identical(x, 
                                                      tipos_de_datos[[1]])))
if (comparacion_tipos) {
  print("Todos los data frames tienen las mismas columnas con el 
        mismo tipo de dato.")
} else {
  print("Hay columnas con diferentes tipos de datos en los siguientes data frames:")
  for (i in 2:length(tipos_de_datos)) {
    
    if (!all(sapply(seq_along(tipos_de_datos[[1]]),
                    function(j) identical(tipos_de_datos[[i]][[j]], 
                                          tipos_de_datos[[1]][[j]])))) {
      columnas_diferentes <- 
        names(tipos_de_datos[[i]])[!(sapply(seq_along(tipos_de_datos[[1]]),
                function(j) identical(tipos_de_datos[[i]][[j]],
                                      tipos_de_datos[[1]][[j]])))]
      
      print(paste("En el data frame", names(tipos_de_datos)[i], "las columnas
                  siguientes tienen tipos de datos diferentes:", 
                  paste(columnas_diferentes, collapse = ", ")))
    }
  }
}
```

Este código proporciona una salida informativa sobre la consistencia de los 
tipos de datos en los data frames, señalando si todos son consistentes o, en 
caso contrario, identificando las columnas específicas y los data frames 
donde se encuentran diferencias.

#### Paso 3: Unificar tipos de datos

Con la sálida del código anterior podemos corregir las discrepancias en los
tipos de datos de algunas columnas:

Como se observa las columnas que presentan diferencias son
`start_station_id` y `end_station_id`, para los data frame que nos proporciona
el código anterior son de tipo `character`, considero que es mejor trabajar 
estos identificadores con el tipo `character` que con el tipo `double` que es
el tipo de dato con el que se encuentran en todos los demas data frame. Por lo
anterior, procedemos a convertir dichas columnas a tipo `character`

#### Conversión de Columnas a Tipo Character en Data Frames

El siguiente bloque de código tiene como objetivo convertir las columnas 
`start_station_id` y `end_station_id` de los data frames almacenados en una l
ista (`lista_dataframes`) a tipo character. Esto es útil cuando se desea 
trabajar con identificadores únicos que contienen solo números y se prefiere 
tratarlos como caracteres. A continuación, se presenta una explicación 
detallada del código:

1. **Definición de la función `convertir_a_character`:**
```{R}
   convertir_a_character <- function(df) {
     mutate(df, 
            start_station_id = as.character(start_station_id),
            end_station_id = as.character(end_station_id))
   }
```

Se crea una función llamada `convertir_a_character` que toma un data frame `df` 
como entrada. Utiliza la función `mutate` del paquete `dplyr` para convertir 
las columnas `start_station_id` y `end_station_id` a tipo character.

2. **Iteración sobre los valores de `j` y `i`:**
```{R}
   for (j in 20:21) {
     if (j == 20) {
       for (i in 4:11) {
         nombre_variable <- paste("periodo_2020", sprintf("%02d", i), sep="")
         lista_dataframes[[nombre_variable]] <- convertir_a_character(lista_dataframes[[nombre_variable]])
       }
     } else {
       for (i in 1:4) {
         nombre_variable <- paste("periodo_", paste("20", j, sprintf("%02d", i), sep=""), sep="")
         lista_dataframes[[nombre_variable]] <- convertir_a_character(lista_dataframes[[nombre_variable]])
       }
     }
   }
```
Se itera sobre los valores de `j` (20 y 21) para los años 2020 y 2021. 
Dependiendo de la condición `if`, se ajusta la variable `i` y se generan los 
nombres de las variables. Luego, se aplica la función `convertir_a_character`
a los data frames correspondientes almacenados en `lista_dataframes`.

3. **Observaciones:**
   - Asegúrate de tener instalado el paquete `dplyr` antes de ejecutar este 
     código.
   - La función `convertir_a_character` utiliza `mutate` para realizar la 
     conversión de tipo.

### Unificar datos en un único data frame

```{r}
# Combina todos los data frames en uno solo
conjunto_datos <- bind_rows(lista_dataframes)
View(conjunto_datos)
```

### Procesamiento de datos nulos

Para poder ver el conjunto de observaciones que cuentan con datos nulos
ejecutamos el siguiente código:

``` {r}
filas_con_nulos <- tu_data_frame[apply(is.na(tu_data_frame), 1, any), ]
```

1. `is.na(tu_data_frame)`: Esta expresión crea una matriz booleana del mismo
tamaño que `tu_data_frame`, donde cada elemento es `TRUE` si el valor 
correspondiente en `tu_data_frame` es `NA` (nulo), y `FALSE` en caso contrario.

2. `apply(is.na(tu_data_frame), 1, any)`: La función `apply` se utiliza para 
aplicar una función a los márgenes de una matriz o array. En este 
caso, aplicamos la función `any` a lo largo de las filas (especificado por
el argumento `1`). La función `any` devuelve `TRUE` si al menos uno de los 
valores es `TRUE` en cada fila. Esto nos da un vector lógico que indica qué
filas tienen al menos un valor nulo.

3. `tu_data_frame[apply(is.na(tu_data_frame), 1, any), ]`: Finalmente, 
utilizamos este vector lógico para seleccionar las filas de `tu_data_frame` 
donde al menos un valor es nulo. Entonces, `filas_con_nulos` contendrá 
únicamente las filas que tienen datos nulos.

```{r}
str(filas_con_nulos)
```

Tenemos `234 800` columnas que contienen datos nulos, vamos a verificar 
el número de nulos en cada una de las columnas

```{r}
# Nombre del data frame
nombre_data_frame <- filas_con_nulos

# Inicializar una lista para almacenar los conteos de nulos por columna
conteos_nulos <- list()

# Iterar sobre todas las columnas del data frame
for (nombre_columna in colnames(nombre_data_frame)) {
  # Contar valores nulos en la columna específica
  nulos_en_columna <- sum(is.na(nombre_data_frame[[nombre_columna]]))
  
  # Imprimir el resultado
  print(paste("Número de valores nulos en", nombre_columna, ":", nulos_en_columna))
  
  # Almacenar el resultado en la lista
  conteos_nulos[[nombre_columna]] <- nulos_en_columna
}

```

La salida nos muestra que la mayor cantidad de nulos la encontramos en las
variables `start_station_name`, start_station_id, end_station_name y 
end_station_id. Es dceri, tenemos la mayor densidad de nulos en información
referente a las estaciones de inicio y de termino del viaje. Para fines de
nuestro analisis es importante conocer esta información ya que se busca poder
determinar con ella una distancia aproximada de viaje recorrido. Sin embargo,
estos datos representan un 6.14 % del universo de datos. Por lo que omitiremos
estos datos para fines de conocer la distancia aproximada de viaje pero pueden
proporcionar información útil sobre el tipo de miembro.

### Verificar duplicados

```{r}
# Nombre de tu data frame
nombre_data_frame <- conjunto_datos

# Verificar si hay duplicados en el data frame
hay_duplicados <- any(duplicated(nombre_data_frame))

# Imprimir el resultado
if (hay_duplicados) {
  print("Existen datos duplicados en el data frame.")
} else {
  print("No hay datos duplicados en el data frame.")
}

```

La salida indica que no existen datos duplicados, para terminar nuestro
procesamiento procedemos a ordenarlos

</div>