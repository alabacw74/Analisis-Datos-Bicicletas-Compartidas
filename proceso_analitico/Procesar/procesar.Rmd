---
title: 'Procesamiento: Conjunto de datos de Cyclistic'
author: 
  - "Alfredo Aburto Alcudia"
  - "https://github.com/alabacw74/analisis-datos-bicicletas-compartidas"
date: "`r Sys.Date()`"
output:
   html_document:
    toc: true # Mostrar tabla de contenido en documento R markdown
    toc_depth: 5 # Niveles de la tabla de contenidoo
    toc_float: true # Mostrar la tabla de contenido en todo el documento
    collapsed: true # Si solo queremos que muestre el nivel principal
    smooth_scroll: true # Reflejar nuestra ubicación en barra de contenido
    theme: journal # Estilo del documento
    highlight: kate # Estilo del codigo
    df_print: paged # Estilo para mostrar los datos
    code_folding: show # Mostrar o no el código del documento
---

<div style="text-align: justify;">

## Objetivo 

En esta fase del analísis realizaremos las operaciones necesarias para obtener
los siguientes resultados:

1. Datos organizados
2. Datos limpios y filtrados
3. Una documentación detallada de cada operación

## Introducción

Como se menciono en la fase de `Prepararación` nuestro conjunto de datos incluye
la información sobre los viajes historicos en formato .zip, siendo en total
trece ficheros. Los conjuntos de datos superan el **millón de registros** es 
por eso que definir una herramienta adecuada para procesar los datos y 
posteriormente poder analizarlos de manera eficiente y profesional es de vital
importancia. Por lo anterior, en este documento incluimos la definición de la
herramienta a utilizar y la documentación de la limpieza de los datos para 
poder tener un flujo de trabajo adecuado y poder avanzar en el proceso de
analisís de los datos sin contratiempos.

## Importación de los datos

```{r carga_paquetes}
# Instala dplyr

# install.packages("tydyverse")

# Carga del paquete
library(tidyverse)
```

### Automatización de lectura de los archivos

La forma en la que se ha realizado la adquisición de los datos nos llevo a tener
archivos aislados con nombres diferentes, para poder realizar la lectura de los
archivos .csv extraidos y unirlos en un data frame creamos el siguiente script
que automatiza dicha tarea. El siguiente bloque de código se encarga de 
automatizar la lectura de archivos CSV correspondientes a datos de viajes 
en bicicleta durante los años 2020 y 2021. A continuación, se proporciona 
una documentación detallada del funcionamiento de este script:

#### Paso 1: Incialización de la lista
1. En este paso, se crea una lista llamada `lista_dataframes` que se utilizará 
para almacenar cada data frame importado.
   
```{r}
lista_dataframes <- list()
```

#### Paso 2: Estructura de Ciclos For

```{r}
# Iteramos sobre valores de la variable j (20 y 21) para los años 2020 y 2021
for (j in 20:21) {
  # Ajustamos la variable i según la estructura de los nombres de los archivos
  if (j == 20) {
    for (i in 4:12) {
      # Generamos el nombre de la variable y del archivo a leer
      nombre_variable <- paste("periodo_2020", sprintf("%02d", i), sep="")
      archivo_csv <- paste("~/Desktop/Analisis_de_datos/Cyclistic_Datasets/",
                           paste("20", j, sprintf("%02d", i), 
                                 "-divvy-tripdata.csv", sep=""),
                           sep="")
      
      # Leemos el archivo CSV y asignamos el resultado a la lista de data frames
      assign(nombre_variable, read_csv(archivo_csv))
      lista_dataframes[[nombre_variable]] <- get(nombre_variable)
    }
  } else {
    for (i in 1:4) {
      # Generamos el nombre de la variable y del archivo a leer
      nombre_variable <- paste("periodo_", paste("20", j, sprintf("%02d", i),
                                                 sep=""), sep="")
      archivo_csv <- paste("~/Desktop/Analisis_de_datos/Cyclistic_Datasets/",
                           paste("20", j, sprintf("%02d", i), 
                                 "-divvy-tripdata.csv", sep=""),
                           sep="")
      
      # Leemos el archivo CSV y asignamos el resultado a la lista de data frames
      assign(nombre_variable, read_csv(archivo_csv))
      lista_dataframes[[nombre_variable]] <- get(nombre_variable)
    }
  }
}

```

Este bloque de código realiza la lectura de archivos CSV de manera dinámica, 
adaptándose a la estructura de nombres de archivos para los años 2020 y 2021. 
Cada conjunto de datos leído se almacena en la lista lista_dataframes, 
facilitando su manipulación posterior. La estructura de ciclos y la generación 
dinámica de nombres garantizan la automatización del proceso de lectura y 
carga de datos.

## Limpieza de los datos

### Verificar tipos de datos

En esta sección del análisis, se busca verificar que todos los data frames 
tengan las mismas columnas con el mismo tipo de dato. Esto es esencial antes de
combinar los data frames en uno solo.

#### Paso 1: Creación de la Lista de Tipos de Datos

Para cada periodo de tiempo (ya sea del año 2020 o 2021), se crea una entrada 
en la lista `tipos_de_datos`. Se utiliza un bucle anidado para iterar sobre 
los periodos y las fechas, obteniendo así los tipos de datos de cada columna 
de cada data frame.

```{r}
tipos_de_datos <- list()

for (j in 20:21) {
  if (j == 20) {
    for (i in 4:12) {
      nombre_variable <- paste("periodo_2020", sprintf("%02d", i), sep="")
      tipos_de_datos[[nombre_variable]] <- sapply(get(nombre_variable), class)
    }
  } else {
    for (i in 1:4) {
      nombre_variable <- paste("periodo_", paste("20", j, sprintf("%02d", i), sep=""), sep="")
      tipos_de_datos[[nombre_variable]] <- sapply(get(nombre_variable), class)
    }
  }
}
```

#### Paso 2: Comparación de Tipos de datos

Luego de obtener los tipos de datos de cada columna de cada data frame, se 
realiza una comparación para verificar si todas las columnas tienen el mismo 
tipo de dato en todos los data frames.

```{r}
comparacion_tipos <- all(sapply(tipos_de_datos[-1],
                                function(x) identical(x, tipos_de_datos[[1]])))
if (comparacion_tipos) {
  print("Todos los data frames tienen las mismas columnas con el mismo tipo de dato.")
} else {
  print("Hay columnas con diferentes tipos de datos en los siguientes data frames:")
  for (i in 2:length(tipos_de_datos)) {
    if (!all(sapply(seq_along(tipos_de_datos[[1]]), function(j) identical(tipos_de_datos[[i]][[j]], tipos_de_datos[[1]][[j]])))) {
      columnas_diferentes <- names(tipos_de_datos[[i]])[!(sapply(seq_along(tipos_de_datos[[1]]), function(j) identical(tipos_de_datos[[i]][[j]], tipos_de_datos[[1]][[j]])))]
      print(paste("En el data frame", names(tipos_de_datos)[i], "las columnas siguientes tienen tipos de datos diferentes:", paste(columnas_diferentes, collapse = ", ")))
    }
  }
}
```

Este código proporciona una salida informativa sobre la consistencia de los 
tipos de datos en los data frames, señalando si todos son consistentes o, en 
caso contrario, identificando las columnas específicas y los data frames 
donde se encuentran diferencias.

```{r}
# Combina todos los data frames en uno solo
# conjunto_datos <- bind_rows(lista_dataframes)
```

</div>